https://redis.io
The open source, in-memory data store used by millions of developers as a database, cache, streaming engine, and message broker.
[Redis](http://redis.io/) (Remote Dictionary Service) — это опенсорсный сервер баз данных типа ключ-значение.
https://habr.com/ru/companies/wunderfund/articles/685894/

Вот какие типы данных поддерживает Redis:
- Строка (String)
- Битовый массив (Bitmap)
- Битовое поле (Bitfield)
- Хеш-таблица (Hash)
- Список (List)
- Множество (Set)
- Упорядоченное множество (Sorted set)
- Геопространственные данные (Geospatial)
- Структура HyperLogLog (HyperLogLog)
- Поток (Stream)
- ![[Pasted image 20231121081522.png]]
Redis — это база данных, размещаемая в памяти, которая используется, в основном, в роли кеша, находящегося перед другой, «настоящей» базой данных, вроде MySQL или PostgreSQL. Кеш, основанный на Redis, помогает улучшить производительность приложений. Он эффективно использует скорость работы с данными, характерную для памяти, и смягчает нагрузку центральной базы данных приложения, связанную с обработкой следующих данных:
- Данные, которые редко меняются, к которым часто обращается приложение.
- Данные, не относящиеся к критически важным, которые часто меняются.
    

Примеры таких данных могут включать в себя сессионные кеши или кеши данных, а так же содержимое панелей управления — вроде списков лидеров и отчётов, включающих в себя данные, агрегированные из разных источников.
![[Pasted image 20231121081710.png]]
Традиционный подход к использованию Redis выглядит следующим образом: клиент обращается к приложению, а оно получает необходимые для выполнения его запроса данные. Сначала (пункт 1 на рисунке) приложение обращается к кешу Redis представленному главной базой данных (Main). Если данные в кеше есть, произошло попадание кеша, выполняется обычный возврат данных. Если произошёл промах кеша (пункт 2), система обращается к постоянному хранилищу (в данном случае — базе данных MySQL). Данные из него (пункт 3) загружаются в кеш, после чего ими сможет воспользоваться приложение.

Изначально Redis чаще всего сравнивали с Memcached, с системой, в которой тогда не было и намёка на долговременное хранение данных.

Хранилище Memcached создал в 2003 году Брэд Фицпатрик. Оно появилось на 6 лет раньше Redis. Сначала это был Perl-проект, а позже его переписали на C. В своё время Memcached был стандартным инструментом кеширования. Главные различия между ним и Redis заключаются в том, что в Memcached имеется меньше типов данных, и в ограничениях, связанных с политикой вытеснения ключей. Memcached поддерживает лишь политику LRU (Least Recently Used), когда первыми вытесняются данные, которые не использовались дольше всех.

Ещё одно отличие этих хранилищ заключается в том, что Redis — это однопоточная система, а Memcached — многопоточная. Memcached может показывать отличные результаты производительности в ограниченных окружениях кеширования. А при использовании этой системы в распределённом кластере нужны дополнительные настройки. Redis же поддерживает подобные сценарии работы сразу после установки

![[Pasted image 20231121082637.png]]
```
import redis
import sqlite3

# Подключение к Redis

redis_connection = redis.Redis(host='localhost', port=6379)

  

# Подключение к базе данных SQLite

sqlite_connection = sqlite3.connect('example.db')
sqlite_cursor = sqlite_connection.cursor()

  

# Проверяем наличие данных в Redis

if redis_connection.exists('example_data'):
# Если данные есть в Redis, получаем их
data = redis_connection.get('example_data')
print('Данные получены из Redis:', data)

else:

# Если данных нет в Redis, выполняем запрос к базе данных
sqlite_cursor.execute('SELECT * FROM example_table')
data = sqlite_cursor.fetchall()

  

# Сохраняем полученные данные в Redis
redis_connection.set('example_data', data)
print('Данные сохранены в Redis:', data)

  

# Закрываем подключения

sqlite_connection.close()
redis_connection.close()

В этом примере мы используем библиотеки redis для работы с Redis и sqlite3 для работы с базой данных SQLite. 

Сначала мы создаем подключение к Redis и SQLite базе данных. Затем мы проверяем, есть ли данные в Redis, вызывая метод exists() с ключом example_data. Если данные есть, мы получаем их с помощью метода get() и выводим их на экран. Если данные отсутствуют, мы выполняем запрос к базе данных SQLite с помощью метода execute() и получаем результат вызовом fetchall(). Затем мы сохраняем полученные данные в Redis с помощью метода set() и выводим их на экран.

```